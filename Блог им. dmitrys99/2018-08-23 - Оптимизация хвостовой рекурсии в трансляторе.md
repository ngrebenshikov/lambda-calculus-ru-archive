# Оптимизация хвостовой рекурсии в трансляторе

Дата создания: 2018-08-23

Автор: dmitrys99

Теги: алгоритмы,трансляторы,хвостовая рекурсия

 ![Хвостовая рекурсия кошка](../images/4b93e1.jpg "Хвостовая рекурсия кошек")  
[Источник картинки](http://pilat888.gorod.tomsk.ru/index-1470134327.php)  
  

#### О&nbsp;чем это вообще?
  
В&nbsp;ежедневной работе программисты, пишущие на&nbsp;императивных языках, нечасто сталкиваются с&nbsp;рекурсивными алгоритмами. Для функциональных&nbsp;же языков рекурсия&nbsp;— естественный способ записи алгоритмов. И&nbsp;пока эти два мира не&nbsp;пересекаются, мало кто задумывается о&nbsp;том, что рекурсия может быть довольно дорогим удовольствием в&nbsp;вычислительном плане. Нет рекурсии&nbsp;— нет проблем.  
  
Сложности начинаются тогда, когда приходится отображать функциональный подход на&nbsp;императивный. Так, если есть необходимость организовать компиляцию из&nbsp;функционального языка в&nbsp;императивный, например ML&nbsp;в Java или Javascript.  
  
Проблема рекурсивных вызовов в&nbsp;том, что на&nbsp;вызов тратится место в&nbsp;стеке вызовов, т.к. каждый новый рекурсивный вызов, помимо затрат на&nbsp;исполнение тела функции, дополнительно сохраняет точку возврата из&nbsp;текущей функции.  
А&nbsp;в&nbsp;рекурсивных алгоритмах количество вызовов может быть большим или очень большим. Стек вызовов исчерпывается очень быстро. Частичным решением служит увеличение размера стека вызовов, однако практически это слабо помогает.  
  

#### Что сложного&nbsp;то?
  
Практический размер стека вызовов редко превосходит несколько тысяч элементов. Это не&nbsp;позволяет делать, например, рекурсивный обход больших бинарный деревьев. И&nbsp;если на&nbsp;императивных языках это можно исправить путем переписывания рекурсивного алгоритма в&nbsp;явно циклический алгоритм (обычно за&nbsp;счет существенного его усложнения), то&nbsp;в&nbsp;функциональных языках избавиться от&nbsp;рекурсии бывает сложно или вообще невозможно.  
  
Перейдем к&nbsp; ~~кошкам~~ примеру.  
  
Есть функция for():  
  

```
// ML-подобный язык
for (init, predicate, fn) {
    if (predicate(init))
        for (fn(init), predicate, fn)
    else init
}
```
  
  
Транслятор переведет ее&nbsp;в&nbsp;Java или Javascript один в&nbsp;один, никакой магии (приведен код на&nbsp;Javascript):  
  

```
// Javascript
function for__(init, predicate, fn) {
        if (predicate(init)) {
            return for__(fn(init), predicate, fn);
        } else {
            return init;
        }
    }
}
```
  
  
Она даже синтаксически будет выглядеть практически также.  
  
Разумеется, на&nbsp;той&nbsp;же Java эту функцию вполне можно заменить обычным циклом. Но&nbsp;мы&nbsp;же в&nbsp;трансляторе это делаем, нам нужен автоматический перевод, верно?  
  
Поэтому мы&nbsp;получим рекурсивный вызов. Ну&nbsp;и&nbsp;следом во&nbsp;время выполнения получим исчерпание стека вызовов.  
  

#### Что делать? Спасите, помогите!
  
Чтобы исправить ситуацию и&nbsp;как-то заставить это работать, разработана техника, позволяющая экономить место в&nbsp;стеке вызовов или избавиться от&nbsp;рекурсивных вызовов вообще.  
  
Мы&nbsp;модифицируем функции таким образом, чтобы изменить рекурсивный вызов на&nbsp;цикл. Это возможно, но, к&nbsp;сожалению, заменить можно не&nbsp;все рекурсивные вызовы. Так, чтобы вызов функции можно было заменить на&nbsp;итерацию цикла, нужно соблюсти несколько условий:  
  

1. вызов функции должен быть последним в&nbsp;последовательности операций;
2. это должен быть именно рекурсивное обращение к&nbsp;функции, без каких-либо дополнительный операций (например, в&nbsp;вычислении факториала, куда уж&nbsp;без него!, выражение n\*fac(n-1) нельзя автоматически заменить на&nbsp;циклический вызов);
3. вызов функции не&nbsp;может быть вложен в&nbsp;замыкание, т.е.&nbsp;в&nbsp;случае с&nbsp;for() конструкция for(..., \x-\>for()..., ...) не&nbsp;будет заменена на&nbsp;циклическую.

  
Выполнения этих условий достаточно, чтобы рекурсивный вызов можно было заменить на&nbsp;итерацию цикла. Из-за первого условия (вызов находится в&nbsp;конце последовательности) это явление получило название [«хвостовая рекурсия»](https://ru.wikipedia.org/wiki/Хвостовая_рекурсия).  
  
Решение состоит в&nbsp;том, что мы&nbsp;функцию с&nbsp;хвостовой рекурсией заменяем на&nbsp;цикл, в&nbsp;котором производим манипуляции с&nbsp;аргументами функции так, как если&nbsp;бы мы&nbsp;готовили рекурсивный вызов, а&nbsp;затем передаем управление в&nbsp;начало цикла.  
  
Есть масса способов это сделать, на&nbsp;просторах Интернета можно найти разные решения.  
  
Я&nbsp;покажу два решения, которые успешно применяются в&nbsp;трансляторах.  
  

##### Решение первое
  
Функция предварительно готовится с&nbsp;помощью вспомогательной операции:  
  

```
// Javascript
function TCO(fn, fn_name) {
    var top_args;
    window[fn_name] = function() {
        var result, old_top_args = top_args;
        top_args = arguments;
        while (top_args !== null) {
            var cur_args = top_args;
            top_args = null;
            result = fn.apply(null, cur_args);
        }
        top_args = old_top_args;
        return result;
    };
    window['tc_' + fn_name] = function() {
        top_args = arguments;
    };
}

TCO((init, predicate, fn) => {
    if (predicate(init)) {
        return tc_for__(fn(init), predicate, fn);
    } else {
        return init;
    }
}, 'for__');
```
  
  
Мы&nbsp;запускаем цикл по&nbsp;аргументам функции, вычисляем тело функции, а&nbsp;затем, при необходимости произвести рекурсивный вызов, модифицируем аргументы, с&nbsp;которыми работает тело функции. Модификацией аргументов занимается дополнительная функция, создаваемая в&nbsp;процессе подготовки функции. В&nbsp;приведенном фрагменте это функция, наименование которой начинается с&nbsp;префикса «tc\_»  
  
Метод работает безупречно, правда медленно. Виной тому использование метода не&nbsp;самого быстрого метода fn.apply(). В&nbsp;Java используется рефлексия, которая тоже дает падение производительности.  
  
Этих недостатков лишен второй метод.  
  

##### Второй метод
  
Поскольку речь идет о&nbsp;внутренностях транслятора, мы&nbsp;многое знаем о&nbsp;модифицируемой функции. Создадим явный цикл и&nbsp;будем самостоятельно заниматься модификацией аргументов.  
  

```
// Javascript
function for__(init, predicate, fn) {
    T: while (true) {
        if (predicate(init)) {
            let $a_ = fn(init);
            let $b_ = predicate;
            let $c_ = fn;
            init = $a_;
            predicate = $b_;
            fn = $c_;
            continue T
        } else {
            return init;
        }
    }
}
```
  
  
Для каждого аргумента функции, вызываемой рекурсивно, мы&nbsp;создаем дополнительную переменную, а&nbsp;следующим шагом возвращаем значения в&nbsp;аргументы фукнции. Дополнительный шаг нужен на&nbsp;случай использования агрументов в&nbsp;сложных выражениях.  
  
Очевидную оптимизацию с&nbsp;неизменяемыми аргументами (см. $b\_ = predicate;) оставлю пытливому читателю для самостоятельного изучения.  
  
Поскольку технически рекурсивный вызов функции отсутствует, этот метод существенно производительнее предыдущего. В&nbsp;большинстве случаев это работает хорошо. Однако мы&nbsp;столкнулись с&nbsp;интересной проблемой, заставившей изрядно поломать голову.  
  

#### Неожиданная проблема
  
Есть функция, в&nbsp;которой хвостовой рекурсивный вызов параметром получает функцию.  
  
Модификации аргументов в&nbsp;приведенном методе недостаточно, если в&nbsp;рекурсивный вызов уходит замыкание, использующее аргументы исходной функции.  
  

```
// ML-подобный язык
main() {
    recursiveFn(1, \res -> println("Внешний вызов. Результат = " + int2str(res)));
}

recursiveFn(counter : int, onOK : (int) -> void) -> void {
	println("Шапка recursiveFn. Counter = " + int2str(counter));

	if (counter > 1) {
		println("Первая ветка recursiveFn. Counter = " + int2str(counter));
		onOK(counter)
	} else {
		println("Вторая ветка recursiveFn. Counter = " + int2str(counter));
		recursiveFn(counter + 1, \newCount -> {
			println("Внутренний вызов. newCounter = " + int2str(newCount));
			onOK(newCount);
		});
	}
}
```
  
  
Ключевой момент&nbsp;— вызов функции onOK после println("Внутренний вызов. newCounter = " + int2str(newCount)).  
  
Если&nbsp;мы, что называется, в&nbsp;лоб, преобразуем функцию в&nbsp;Javascript, результатом будет бесконечная рекурсия.  
  

```
// Javascript
function main() {
    return recursiveFn(1, ((res) => {
        return println(("Внешний вызов. Результат = " + int2str(res)));
    }));
}

function recursiveFn(counter, onOK) {
    T: while (true) {
        println(("Шапка recursiveFn. Counter = " + int2str(counter)));
        if ((counter > 1)) {
            println(("Первая ветка recursiveFn. Counter = " + int2str(counter)));
            return onOK(counter);
        } else {
            println(("Вторая ветка recursiveFn. Counter = " + int2str(counter)));

            let $a_ = ((counter + 1) | 0);
            let $b_ = ((newCount) => {
                println(("Внутренний вызов. newCounter = " + int2str(newCount)));
                return onOK(newCount);
            });
            counter = $a_;
            onOK = $b_;
            continue T
        }
    }
}
```
  
  
Неважно что будет стоять после строки println(("Внутренний вызов. newCounter = " + int2str(newCount))), onOK или $b\_. Мы&nbsp;получим бесконечную рекурсию из-за того, что замыкание использует внешнее значение функционального параметра onOK.  
  
Проблема заключается в&nbsp;том, что замыкание должно оставаться замыканием, т.е. должно захватывать лексическое окружение. Мы&nbsp;же это самое окружение модифицируем для подмены рекурсии циклом. Решение заключается в&nbsp;честной модификации лексического окружения с&nbsp;передачей модифицированных параметров:  
  

```
// Javascript
function main() {
    return recursiveFn(1, ((res) => {
        return println(("Внешний вызов. Результат = " + int2str(res)));
    }));
}

function recursiveFn(counter, onOK) {
    T: while (true) {
        println(("Шапка recursiveFn. Counter = " + int2str(counter)));
        if ((counter > 1)) {
            println(("Первая ветка recursiveFn. Counter = " + int2str(counter)));
            return onOK(counter);
        } else {
            println(("Вторая ветка recursiveFn. Counter = " + int2str(counter)));

            let $_ta = onOK;
            let $a_ = ((counter + 1) | 0);
            let $b_ = ((newCount) => {
                println(("Внутренний вызов. newCounter = " + int2str(newCount)));
                return $_ta(newCount);
            });
            counter = $a_;
            onOK = $b_;
            continue T
        }
    }
}
```
  
  
Внимание следует обратить на&nbsp;переменную $\_ta, которая уже внутри замыкания используется вместо onOK.  
  
При трансляции мы&nbsp;модифицируем лексическое окружение для генерации кода замыкания. После генерации тела замыкания лексическое окружение восстанавливается, чтобы не&nbsp;поломать нижележащий код. Это делается тем&nbsp;же способом, что и&nbsp;генерация кода для рабочих серверов (в&nbsp;неотладочном режиме).  
  
Этот метод трансляции работает корректно и&nbsp;уже используется в&nbsp;боевых системах.  
  

#### И&nbsp;что, вот так вот и&nbsp;работает?
  
Трансляция хвостовой рекурсии еще споткнулась о&nbsp;ключевые слова. Если посмотреть на&nbsp;определение функции for() выше, то&nbsp;можно увидеть, что в&nbsp;результирующем коде стоит название for\_\_(). Транслятор не&nbsp;видел измененное имя&nbsp;и, соответственно, не&nbsp;помечал его как рекурсивный вызов.  
  
Не&nbsp;рассмотрены остались некоторые сложные случаи вроде взаимной хвостовой рекурсии, однако для&nbsp;_практического использования_ приведенного решения вполне достаточно.